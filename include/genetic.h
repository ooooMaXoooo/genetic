#pragma once
/**
 * @file genetic.h
 * @brief Declarations for the genetic algorithm components (types and operations).
 *
 * This header declares aliases and core functions used to implement a
 * generational genetic algorithm, including agent evaluation, selection,
 * crossover, mutation, generation creation, and utilities for inspecting the
 * population.
 *
 * The exact template parameters and sizes for Agent, Population and
 * HalfPopulation are provided by the included configuration headers.
 *
 * Thread-safety, persistence format and other runtime policies are governed by
 * the broader program and are not defined here.
 */



#include "settings.h"
#include "Individu.h"

#include <array>
#include <utility>



/**
 * @typedef Agent
 * @brief Alias for an individual in the genetic algorithm.
 *
 * Agent represents a single candidate solution (an Individu) instantiated
 * with the compile-time parameters NumberOfVectors and Dimension.
 *
 * The concrete type is determined by the project configuration.
 */
using Agent = Individu<NumberOfVectors, Dimension>;

/**
 * @typedef Population
 * @brief Fixed-size container holding the entire population for one generation.
 *
 * Population is an std::array of Agent with size PopulationSize.
 */
using Population = std::array<Agent, PopulationSize>;

/**
 * @typedef HalfPopulation
 * @brief Fixed-size container representing a half-population used during
 * selection and crossover (e.g., parents or selected survivors).
 *
 * HalfPopulation is an std::array of Agent with size HalfPopulationSize.
 */
using HalfPopulation = std::array<Agent, HalfPopulationSize>;




/**
 * @brief Evaluate the fitness (or objective) of a single agent.
 *
 * @param[in] a The agent to evaluate; evaluation must not modify @p a.
 * @return real A numerical score representing the agent's fitness. Higher or
 *              lower values indicate better quality depending on the problem
 *              convention used in the rest of the codebase.
 *
 * @note The function must be deterministic for a given agent state, except
 *       where explicit stochastic evaluation is intended and accounted for by
 *       the algorithm.
 */
real eval_agent (const Agent& a);

 
/**
 * @brief Perform tournament selection on a population to build a half-size
 * selection pool of parent candidates.
 *
 * @param[in] p The current population to select from.
 * @return HalfPopulation A container of selected agents (typically used as
 *                       parents for crossover).
 *
 * @pre The provided population @p p must be valid and fully-initialized.
 * @post Returned HalfPopulation contains agents selected according to the
 *       tournament selection policy configured elsewhere (ties, tournament
 *       size and replacement policy are implementation-specific).
 */
HalfPopulation selection_tournoi(const Population& p);



/**
 * @brief Produce two offspring by crossing over two parent agents.
 *
 * @param[in] p1 First parent agent.
 * @param[in] p2 Second parent agent.
 * @return std::pair<Agent, Agent> A pair containing the two offspring agents
 *                                  produced from the crossover of @p p1 and
 *                                  @p p2.
 *
 * @note The crossover operator may be symmetric or asymmetric and may include
 *       rules for recombination of vector components and any associated
 *       metadata (e.g., repair, normalization). Mutation is typically applied
 *       in a separate step.
 */
std::pair<Agent, Agent> cross_over (const Agent& p1, const Agent& p2);



/**
 * @brief Apply crossover to a HalfPopulation to produce a full Population of
 * offspring.
 *
 * @param[in,out] hp The half-population (usually selected parents). The
 *                   function may treat this input as read-only, but the
 *                   signature allows modifications if required by the
 *                   implementation.
 * @return Population A full population (PopulationSize elements) of children
 *                    generated by pairing and crossing the entries in @p hp.
 *
 * @pre The size of @p hp must be sufficient for the crossover pairing strategy
 *      (e.g., even number of parents if pairing is required).
 * @post Returned Population contains newly created agents ready for
 *       subsequent mutation and evaluation.
 */
Population cross_over_half_pop (HalfPopulation& hp);



/**
 * @brief Apply mutation operators to every agent in the provided population.
 *
 * @param[in,out] p Pointer to the Population to mutate. Each agent in the
 *                  population may be modified in-place.
 *
 * @pre p must be a non-null pointer to a valid Population.
 * @post The population pointed to by @p p reflects applied mutations. The
 *       function should preserve any invariants required by the rest of the
 *       algorithm (e.g., valid value ranges).
 *
 * @note Mutation intensity, per-gene probabilities, and any constraints or
 *       repair logic are defined by the implementation and configuration.
 */
void mutations (Population* p);



/**
 * @brief Create or evolve a generation for a genetic algorithm population.
 *
 * @details Generates the generation identified by \p indice for the provided
 * Population object. This function performs the genetic operations required to
 * produce the requested generation (selection, crossover, mutation,
 * evaluation and any bookkeeping). When \p is_saving_in_file is true, the
 * resulting generation or relevant population data will be persisted to disk
 * (format and location are determined elsewhere in the program).
 *
 * @param[in] indice Index of the generation to create (typically 0-based).
 *                   The exact interpretation (generation number vs. archive
 *                   position) depends on the calling context.
 * @param[in,out] p Pointer to the Population to be modified. The function
 *                   updates the population in-place to reflect the new
 *                   generation. Must be a valid, non-null pointer.
 * @param[in] is_saving_in_file When true, persist generation/population data
 *                              to file; when false, do not perform persistence.
 *                              Default: false.
 *
 * @pre p != nullptr.
 * @pre indice must be within a valid range for the current evolutionary run;
 *      caller is responsible for ensuring index validity.
 *
 * @post The Population object pointed to by \p p represents the generation
 *       indicated by \p indice (individuals and associated metadata updated,
 *       fitnesses evaluated, and any internal counters advanced).
 *
 * @note • Saving behavior (file format, naming, location) is implementation-specific and governed by other components of the codebase.
 * @note • Side effects may include dynamic allocation of individuals, mutation of existing individuals, and I/O when \p is_saving_in_file is true.
 */
void create_generation (size_t indice, Population* p, bool is_saving_in_file = false);


/**
 * @brief Print or log the best agent from a population.
 *
 * @param[in] p The population to inspect.
 *
 * @note The definition of "best" (maximum vs. minimum fitness) is determined
 *       by the evaluation convention used in eval_agent and higher-level
 *       algorithm policies. Output destination (console, log file, structured
 *       report) is implementation-defined.
 */
void print_best_agent(const Population& p);


/**
 * @brief Top-level entry point for running the genetic algorithm.
 *
 * This function is responsible for initializing state, iterating through
 * generations, invoking selection/crossover/mutation/evaluation, and handling
 * termination and final reporting.
 *
 * @note The function may block for the full duration of the evolutionary run
 *       and may perform I/O, profiling and resource management as required by
 *       the program.
 */
void genetic_algorithm ();